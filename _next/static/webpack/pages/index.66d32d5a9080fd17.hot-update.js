"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/lib/Library.ts":
/*!****************************!*\
  !*** ./src/lib/Library.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Library: () => (/* binding */ Library),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/game */ \"(pages-dir-browser)/./src/game.ts\");\n\nclass Library {\n    async load() {\n        try {\n            let url = 'scripts/games.json.gz?v=';\n            if (window.location.href.indexOf('nite') > -1) {\n                url = 'scripts/games.pl.json.gz?v=';\n            }\n            const resp = await fetch(url + Math.random());\n            const gzipBlob = await resp.blob();\n            const decompressedStream = gzipBlob.stream().pipeThrough(new DecompressionStream('gzip'));\n            const decompressedBlob = await new Response(decompressedStream).blob();\n            const decompressedText = await decompressedBlob.text();\n            const parsed = JSON.parse(decompressedText);\n            this.allGames = parsed.map((g)=>{\n                const ng = new _game__WEBPACK_IMPORTED_MODULE_0__.Game();\n                ng.copyPropertyValuesFrom(g);\n                return ng;\n            });\n            // perform the same post-processing as Initializer\n            let bundleCounts = new Map();\n            for (let game of this.allGames){\n                if (game.Bundles && game.Bundles.length > 0) {\n                    for (let bundle of game.Bundles){\n                        var _bundleCounts_get;\n                        bundleCounts.set(bundle, ((_bundleCounts_get = bundleCounts.get(bundle)) !== null && _bundleCounts_get !== void 0 ? _bundleCounts_get : 0) + 1);\n                    }\n                }\n            }\n            for (let game of this.allGames){\n                if (game.Bundles && game.Bundles.length > 0) {\n                    var _bundleCounts_get1;\n                    var bndlCnt = (_bundleCounts_get1 = bundleCounts.get(game.Bundles[0])) !== null && _bundleCounts_get1 !== void 0 ? _bundleCounts_get1 : 0;\n                    if (bndlCnt == 1) {\n                        var _game_BoughtMonth;\n                        game.Bundle = '';\n                        game.Bundles = [];\n                        var _game_BoughtMonth_split_;\n                        game.AddedBundle = (_game_BoughtMonth_split_ = (_game_BoughtMonth = game.BoughtMonth) === null || _game_BoughtMonth === void 0 ? void 0 : _game_BoughtMonth.split('-')[0]) !== null && _game_BoughtMonth_split_ !== void 0 ? _game_BoughtMonth_split_ : '';\n                    }\n                }\n            }\n            let dictCategoryHours = new Map();\n            for (let game of this.allGames){\n                if (game.Playtime != null && game.Categories != null) {\n                    let cat = game.Categories.split('|')[0];\n                    var _dictCategoryHours_get;\n                    let prev = (_dictCategoryHours_get = dictCategoryHours.get(cat)) !== null && _dictCategoryHours_get !== void 0 ? _dictCategoryHours_get : 0;\n                    dictCategoryHours.set(cat, prev + game.Playtime);\n                }\n            }\n            for (let game of this.allGames){\n                if (game.Categories != null) {\n                    var _game_Categories_split;\n                    game.CategoryHours = (_game_Categories_split = game.Categories.split('|')) === null || _game_Categories_split === void 0 ? void 0 : _game_Categories_split.filter((p)=>p != 'Bought' && p != 'Mouse').map((cat)=>{\n                        var _dictCategoryHours_get;\n                        let hrs = (_dictCategoryHours_get = dictCategoryHours.get(cat)) !== null && _dictCategoryHours_get !== void 0 ? _dictCategoryHours_get : 0;\n                        return cat + ' (' + Math.round(hrs / 3600).toString() + 'h)';\n                    }).join('|');\n                }\n            }\n            let gameTimeSums = {};\n            let gameOtherSources = {};\n            for (let game of this.allGames){\n                if (game.Source == 'Steam' && game.Playtime != null) {\n                    game.SteamPlaytime = game.Playtime;\n                }\n                let sameNamedGames = this.allGames.filter((p)=>p.Name == game.Name);\n                if (sameNamedGames.length > 1 && gameTimeSums[game.Name] == null) {\n                    gameTimeSums[game.Name] = sameNamedGames.map((p)=>p.Playtime).reduce((a, b)=>(a !== null && a !== void 0 ? a : 0) + (b !== null && b !== void 0 ? b : 0), 0);\n                }\n            }\n            for (let game of this.allGames.sort((a, b)=>{\n                const sourceOrder = [\n                    'Steam',\n                    'Epic',\n                    'GOG',\n                    'Xbox Game Pass'\n                ];\n                const aIndex = sourceOrder.indexOf(a.Source) !== -1 ? sourceOrder.indexOf(a.Source) : 999;\n                const bIndex = sourceOrder.indexOf(b.Source) !== -1 ? sourceOrder.indexOf(b.Source) : 999;\n                return aIndex - bIndex || a.Source.localeCompare(b.Source);\n            })){\n                let sameNamedGames = this.allGames.filter((p)=>p.Name == game.Name);\n                if (sameNamedGames.length > 1 && gameOtherSources[game.Name] == null) {\n                    gameOtherSources[game.Name] = sameNamedGames.filter((p)=>p.Source != game.Source).map((p)=>p.Source).filter((p)=>p != null);\n                }\n            }\n            for (let game of this.allGames){\n                if (gameTimeSums[game.Name] != null) {\n                    game.Playtime = gameTimeSums[game.Name];\n                }\n                if (gameOtherSources[game.Name] != null) {\n                    game.OtherSources = gameOtherSources[game.Name];\n                }\n            }\n            for (let game of this.allGames){\n                var _game_Categories, _game_Categories_split1, _game_Categories1;\n                var _game_Source;\n                game.uri = 'plgame://' + game.Id + '?game=' + encodeURI(game.GameId) + '&source=' + encodeURI((_game_Source = game.Source) !== null && _game_Source !== void 0 ? _game_Source : '-1') + '&name=' + encodeURI(game.Name) + '&cat=' + encodeURI(game.Deck);\n                var _game_Categories_indexOf;\n                game.Bought = ((_game_Categories_indexOf = (_game_Categories = game.Categories) === null || _game_Categories === void 0 ? void 0 : _game_Categories.indexOf('Bought')) !== null && _game_Categories_indexOf !== void 0 ? _game_Categories_indexOf : -1) > -1;\n                var _game_Categories_split_filter_join;\n                game.Categories = (_game_Categories_split_filter_join = (_game_Categories1 = game.Categories) === null || _game_Categories1 === void 0 ? void 0 : (_game_Categories_split1 = _game_Categories1.split('|')) === null || _game_Categories_split1 === void 0 ? void 0 : _game_Categories_split1.filter((p)=>p != 'Bought').join('|')) !== null && _game_Categories_split_filter_join !== void 0 ? _game_Categories_split_filter_join : null;\n                // Normalize CompletionStatus: convert empty/whitespace strings to null and trim values\n                if (typeof game.CompletionStatus === 'string') {\n                    const cs = game.CompletionStatus.trim();\n                    game.CompletionStatus = cs === '' ? null : cs;\n                } else if (game.CompletionStatus == null) {\n                    game.CompletionStatus = null;\n                }\n            }\n            // Merge information from hidden duplicates into their visible counterparts.\n            // For games that share the same Name or the same SteamId, copy non-trivial\n            // CompletionStatus from hidden entries to the non-hidden entry and\n            // concatenate distinct Categories.\n            const meaningfulStatuses = new Set([\n                null,\n                'Not Played',\n                'Played'\n            ]);\n            for (const visible of this.allGames.filter((g)=>!g.Hidden)){\n                const related = this.allGames.filter((p)=>p !== visible && (p.Name === visible.Name || p.SteamId && p.SteamId === visible.SteamId));\n                const hiddenRelated = related.filter((p)=>p.Hidden);\n                if (hiddenRelated.length === 0) continue;\n                // Copy CompletionStatus from the first hidden related entry that has a meaningful (non-default) value\n                for (const h of hiddenRelated){\n                    var _h_CompletionStatus;\n                    const hcs = (_h_CompletionStatus = h.CompletionStatus) !== null && _h_CompletionStatus !== void 0 ? _h_CompletionStatus : null;\n                    if (hcs != null && hcs !== 'Not Played' && hcs !== 'Played') {\n                        if (visible.CompletionStatus == null || visible.CompletionStatus === 'Not Played' || visible.CompletionStatus === 'Played') {\n                            visible.CompletionStatus = hcs;\n                            break;\n                        }\n                    }\n                }\n                // Concatenate distinct Categories from hidden related entries\n                const cats = new Set();\n                if (visible.Categories) visible.Categories.split('|').forEach((c)=>{\n                    if (c) cats.add(c);\n                });\n                hiddenRelated.forEach((h)=>{\n                    if (h.Categories) h.Categories.split('|').forEach((c)=>{\n                        if (c) cats.add(c);\n                    });\n                });\n                visible.Categories = cats.size > 0 ? Array.from(cats).join('|') : null;\n            }\n            try {\n                const statusCounts = new Map();\n                for (const g of this.allGames){\n                    var _g_CompletionStatus;\n                    const key = (_g_CompletionStatus = g.CompletionStatus) !== null && _g_CompletionStatus !== void 0 ? _g_CompletionStatus : '<null>';\n                    var _statusCounts_get;\n                    statusCounts.set(key, ((_statusCounts_get = statusCounts.get(key)) !== null && _statusCounts_get !== void 0 ? _statusCounts_get : 0) + 1);\n                }\n                const sorted = Array.from(statusCounts.entries()).sort((a, b)=>b[1] - a[1]);\n                console.info('Library: CompletionStatus counts', sorted);\n                try {\n                    window.__completionStatusCounts = Object.fromEntries(sorted);\n                } catch (e) {\n                // ignore when window not available\n                }\n            } catch (e) {\n            // harmless debug failure\n            }\n            this.isClientStarted = true;\n            this._preloaded = true;\n            this.refreshFilterOptions(this.allGames);\n            window.games = this.allGames;\n        } catch (err) {\n            console.error('Library load failed', err);\n            this.allGames = [];\n        }\n    }\n    getAllGames() {\n        return this.allGames;\n    }\n    getPrecomputedViews() {\n        return this.precomputedViews;\n    }\n    setPrecomputedView(key, view) {\n        this.precomputedViews.set(key, view);\n    }\n    refreshFilterOptions(games) {\n        this.sources = Array.from(new Set(games.map((p)=>{\n            var _p_Source;\n            return (_p_Source = p.Source) !== null && _p_Source !== void 0 ? _p_Source : '';\n        }).filter((s)=>s !== ''))).sort((a, b)=>a.localeCompare(b));\n        this.tags = Array.from(new Set(games.flatMap((p)=>{\n            var _p_Tags;\n            return ((_p_Tags = p.Tags) !== null && _p_Tags !== void 0 ? _p_Tags : '').split('|');\n        }).filter((s)=>s))).sort((a, b)=>a.localeCompare(b));\n        this.genres = Array.from(new Set(games.flatMap((p)=>{\n            var _p_Genres;\n            return ((_p_Genres = p.Genres) !== null && _p_Genres !== void 0 ? _p_Genres : '').split('|');\n        }).filter((s)=>s))).sort((a, b)=>a.localeCompare(b));\n        this.categories = Array.from(new Set(games.flatMap((p)=>{\n            var _p_Categories;\n            return ((_p_Categories = p.Categories) !== null && _p_Categories !== void 0 ? _p_Categories : '').split('|');\n        }).filter((s)=>s))).sort((a, b)=>a.localeCompare(b));\n        const ry = Array.from(new Set(games.map((p)=>p.ReleaseYear).filter((y)=>y != null))).sort((a, b)=>b - a);\n        this.releaseYears = ry.map((p)=>p.toString());\n        const ay = Array.from(new Set(games.map((p)=>{\n            if (!p.Added) return null;\n            const added = p.Added;\n            try {\n                if (typeof added === 'string' && added.indexOf('/Date(') > -1) {\n                    return new Date(parseInt(added.replace('/Date(', '').replace(')/', ''))).getFullYear();\n                }\n                const dt = new Date(added);\n                return isNaN(dt.getFullYear()) ? null : dt.getFullYear();\n            } catch (e) {\n                return null;\n            }\n        }).filter((y)=>y != null))).sort((a, b)=>b - a);\n        this.addedYears = ay.map((p)=>p.toString());\n        const featuresMap = new Map();\n        games.forEach((p)=>{\n            var _p_Features;\n            (_p_Features = p.Features) === null || _p_Features === void 0 ? void 0 : _p_Features.split('|').forEach((f)=>{\n                if (f && f.trim()) {\n                    const lower = f.trim().toLowerCase();\n                    if (!featuresMap.has(lower)) {\n                        featuresMap.set(lower, f.trim());\n                    }\n                }\n            });\n        });\n        this.features = Array.from(featuresMap.values()).sort((a, b)=>a.localeCompare(b, undefined, {\n                sensitivity: 'base'\n            }));\n        this.multi = Array.from(new Set(games.flatMap((p)=>{\n            var _p_Multi;\n            return ((_p_Multi = p.Multi) !== null && _p_Multi !== void 0 ? _p_Multi : '').split('|');\n        }).filter((s)=>s))).sort((a, b)=>a.localeCompare(b));\n        this.ageRatings = Array.from(new Set(games.map((p)=>{\n            var _p_AgeRating;\n            return (_p_AgeRating = p.AgeRating) !== null && _p_AgeRating !== void 0 ? _p_AgeRating : '';\n        }).filter((s)=>s))).sort((a, b)=>a.localeCompare(b));\n    }\n    constructor(){\n        this.allGames = [];\n        this.precomputedViews = new Map();\n        this.sources = [];\n        this.tags = [];\n        this.features = [];\n        this.categories = [];\n        this.genres = [];\n        this.multi = [];\n        this.releaseYears = [];\n        this.addedYears = [];\n        this.ageRatings = [];\n        // Initializer-related\n        this._preloaded = false;\n        this.isClientStarted = false;\n        this.ready = Promise.resolve();\n        if (true) {\n            this.ready = this.load();\n        }\n    }\n}\nconst library = new Library();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (library);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eW5pdGVfbmV4dFxcc3JjXFxsaWJcXExpYnJhcnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2FtZSB9IGZyb20gJ0AvZ2FtZSc7XHJcblxyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgICBpbnRlcmZhY2UgV2luZG93IHtcclxuICAgICAgICBnYW1lcz86IEdhbWVbXTtcclxuICAgIH1cclxufVxyXG5cclxudHlwZSBQcmVjb21wdXRlZFZpZXcgPSB7IGdhbWVzOiBHYW1lW107IGdyb3VwOiB7IGZpZWxkOiBzdHJpbmc7IGRpcjogc3RyaW5nIH1bXTsgdGFrZTogbnVtYmVyIH07XHJcblxyXG5leHBvcnQgY2xhc3MgTGlicmFyeSB7XHJcbiAgICBwdWJsaWMgYWxsR2FtZXM6IEdhbWVbXSA9IFtdO1xyXG4gICAgcHVibGljIHByZWNvbXB1dGVkVmlld3M6IE1hcDxzdHJpbmcsIFByZWNvbXB1dGVkVmlldz4gPSBuZXcgTWFwKCk7XHJcbiAgICBwdWJsaWMgc291cmNlczogc3RyaW5nW10gPSBbXTtcclxuICAgIHB1YmxpYyB0YWdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHVibGljIGZlYXR1cmVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHVibGljIGNhdGVnb3JpZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBwdWJsaWMgZ2VucmVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHVibGljIG11bHRpOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHVibGljIHJlbGVhc2VZZWFyczogc3RyaW5nW10gPSBbXTtcclxuICAgIHB1YmxpYyBhZGRlZFllYXJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHVibGljIGFnZVJhdGluZ3M6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZXItcmVsYXRlZFxyXG4gICAgcHJpdmF0ZSBfcHJlbG9hZGVkID0gZmFsc2U7XHJcbiAgICBwdWJsaWMgaXNDbGllbnRTdGFydGVkID0gZmFsc2U7XHJcbiAgICBwdWJsaWMgcmVhZHk6IFByb21pc2U8dm9pZD4gPSBQcm9taXNlLnJlc29sdmUoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRoaXMubG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCB1cmwgPSAnc2NyaXB0cy9nYW1lcy5qc29uLmd6P3Y9JztcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJ25pdGUnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSdzY3JpcHRzL2dhbWVzLnBsLmpzb24uZ3o/dj0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaCh1cmwgKyBNYXRoLnJhbmRvbSgpKTtcclxuICAgICAgICAgICAgY29uc3QgZ3ppcEJsb2IgPSBhd2FpdCByZXNwLmJsb2IoKTtcclxuICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VkU3RyZWFtID0gZ3ppcEJsb2Iuc3RyZWFtKCkucGlwZVRocm91Z2gobmV3IERlY29tcHJlc3Npb25TdHJlYW0oJ2d6aXAnKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZEJsb2IgPSBhd2FpdCBuZXcgUmVzcG9uc2UoZGVjb21wcmVzc2VkU3RyZWFtKS5ibG9iKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZFRleHQgPSBhd2FpdCBkZWNvbXByZXNzZWRCbG9iLnRleHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvbXByZXNzZWRUZXh0KSBhcyBhbnlbXTtcclxuICAgICAgICAgICAgdGhpcy5hbGxHYW1lcyA9IHBhcnNlZC5tYXAoZyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZyA9IG5ldyBHYW1lKCk7XHJcbiAgICAgICAgICAgICAgICBuZy5jb3B5UHJvcGVydHlWYWx1ZXNGcm9tKGcgYXMgR2FtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmc7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgc2FtZSBwb3N0LXByb2Nlc3NpbmcgYXMgSW5pdGlhbGl6ZXJcclxuICAgICAgICAgICAgbGV0IGJ1bmRsZUNvdW50cyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGdhbWUgb2YgdGhpcy5hbGxHYW1lcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdhbWUuQnVuZGxlcyAmJiBnYW1lLkJ1bmRsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGJ1bmRsZSBvZiBnYW1lLkJ1bmRsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlQ291bnRzLnNldChidW5kbGUsIChidW5kbGVDb3VudHMuZ2V0KGJ1bmRsZSkgPz8gMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FtZSBvZiB0aGlzLmFsbEdhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZS5CdW5kbGVzICYmIGdhbWUuQnVuZGxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJuZGxDbnQgPSBidW5kbGVDb3VudHMuZ2V0KGdhbWUuQnVuZGxlc1swXSkgPz8gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm5kbENudCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhbWUuQnVuZGxlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhbWUuQnVuZGxlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1lLkFkZGVkQnVuZGxlID0gZ2FtZS5Cb3VnaHRNb250aD8uc3BsaXQoJy0nKVswXSA/PyAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGRpY3RDYXRlZ29yeUhvdXJzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FtZSBvZiB0aGlzLmFsbEdhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZS5QbGF5dGltZSAhPSBudWxsICYmIGdhbWUuQ2F0ZWdvcmllcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhdCA9IGdhbWUuQ2F0ZWdvcmllcy5zcGxpdCgnfCcpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gZGljdENhdGVnb3J5SG91cnMuZ2V0KGNhdCkgPz8gMDtcclxuICAgICAgICAgICAgICAgICAgICBkaWN0Q2F0ZWdvcnlIb3Vycy5zZXQoY2F0LCBwcmV2ICsgZ2FtZS5QbGF5dGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FtZSBvZiB0aGlzLmFsbEdhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZS5DYXRlZ29yaWVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLkNhdGVnb3J5SG91cnMgPSBnYW1lLkNhdGVnb3JpZXMuc3BsaXQoJ3wnKT8uZmlsdGVyKHAgPT4gcCAhPSAnQm91Z2h0JyAmJiBwICE9ICdNb3VzZScpLm1hcChjYXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaHJzID0gZGljdENhdGVnb3J5SG91cnMuZ2V0KGNhdCkgPz8gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhdCArICcgKCcgKyBNYXRoLnJvdW5kKGhycyAvIDM2MDApLnRvU3RyaW5nKCkgKyAnaCknO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJ3wnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGdhbWVUaW1lU3VtczogeyBbbmFtZTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcclxuICAgICAgICAgICAgbGV0IGdhbWVPdGhlclNvdXJjZXM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZ1tdIH0gPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FtZSBvZiB0aGlzLmFsbEdhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZS5Tb3VyY2UgPT0gJ1N0ZWFtJyAmJiBnYW1lLlBsYXl0aW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLlN0ZWFtUGxheXRpbWUgPSBnYW1lLlBsYXl0aW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHNhbWVOYW1lZEdhbWVzID0gdGhpcy5hbGxHYW1lcy5maWx0ZXIocCA9PiBwLk5hbWUgPT0gZ2FtZS5OYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChzYW1lTmFtZWRHYW1lcy5sZW5ndGggPiAxICYmIGdhbWVUaW1lU3Vtc1tnYW1lLk5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lVGltZVN1bXNbZ2FtZS5OYW1lXSA9IHNhbWVOYW1lZEdhbWVzLm1hcChwID0+IHAuUGxheXRpbWUpLnJlZHVjZSgoYSwgYikgPT4gKGEgPz8gMCkgKyAoYiA/PyAwKSwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FtZSBvZiB0aGlzLmFsbEdhbWVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU9yZGVyID0gWydTdGVhbScsICdFcGljJywgJ0dPRycsICdYYm94IEdhbWUgUGFzcyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYUluZGV4ID0gc291cmNlT3JkZXIuaW5kZXhPZihhLlNvdXJjZSEpICE9PSAtMSA/IHNvdXJjZU9yZGVyLmluZGV4T2YoYS5Tb3VyY2UhKSA6IDk5OTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJJbmRleCA9IHNvdXJjZU9yZGVyLmluZGV4T2YoYi5Tb3VyY2UhKSAhPT0gLTEgPyBzb3VyY2VPcmRlci5pbmRleE9mKGIuU291cmNlISkgOiA5OTk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYUluZGV4IC0gYkluZGV4IHx8IGEuU291cmNlIS5sb2NhbGVDb21wYXJlKGIuU291cmNlISk7XHJcbiAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2FtZU5hbWVkR2FtZXMgPSB0aGlzLmFsbEdhbWVzLmZpbHRlcihwID0+IHAuTmFtZSA9PSBnYW1lLk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhbWVOYW1lZEdhbWVzLmxlbmd0aCA+IDEgJiYgZ2FtZU90aGVyU291cmNlc1tnYW1lLk5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lT3RoZXJTb3VyY2VzW2dhbWUuTmFtZV0gPSBzYW1lTmFtZWRHYW1lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcC5Tb3VyY2UgIT0gZ2FtZS5Tb3VyY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAocCA9PiBwLlNvdXJjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihwID0+IHAgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FtZSBvZiB0aGlzLmFsbEdhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZVRpbWVTdW1zW2dhbWUuTmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuUGxheXRpbWUgPSBnYW1lVGltZVN1bXNbZ2FtZS5OYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChnYW1lT3RoZXJTb3VyY2VzW2dhbWUuTmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuT3RoZXJTb3VyY2VzID0gZ2FtZU90aGVyU291cmNlc1tnYW1lLk5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGdhbWUgb2YgdGhpcy5hbGxHYW1lcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdhbWUudXJpID0gJ3BsZ2FtZTovLycgKyBnYW1lLklkICsgJz9nYW1lPScgKyBlbmNvZGVVUkkoZ2FtZS5HYW1lSWQpICsgJyZzb3VyY2U9JyArIGVuY29kZVVSSShnYW1lLlNvdXJjZSA/PyAnLTEnKSArICcmbmFtZT0nICsgZW5jb2RlVVJJKGdhbWUuTmFtZSkgKyAnJmNhdD0nICsgZW5jb2RlVVJJKGdhbWUuRGVjayk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2FtZS5Cb3VnaHQgPSAoZ2FtZS5DYXRlZ29yaWVzPy5pbmRleE9mKCdCb3VnaHQnKSA/PyAtMSkgPiAtMTtcclxuICAgICAgICAgICAgICAgIGdhbWUuQ2F0ZWdvcmllcyA9IGdhbWUuQ2F0ZWdvcmllcz8uc3BsaXQoJ3wnKT8uZmlsdGVyKHAgPT4gcCAhPSAnQm91Z2h0Jykuam9pbignfCcpID8/IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgQ29tcGxldGlvblN0YXR1czogY29udmVydCBlbXB0eS93aGl0ZXNwYWNlIHN0cmluZ3MgdG8gbnVsbCBhbmQgdHJpbSB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2FtZS5Db21wbGV0aW9uU3RhdHVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gZ2FtZS5Db21wbGV0aW9uU3RhdHVzLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLkNvbXBsZXRpb25TdGF0dXMgPSBjcyA9PT0gJycgPyBudWxsIDogY3M7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdhbWUuQ29tcGxldGlvblN0YXR1cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5Db21wbGV0aW9uU3RhdHVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWVyZ2UgaW5mb3JtYXRpb24gZnJvbSBoaWRkZW4gZHVwbGljYXRlcyBpbnRvIHRoZWlyIHZpc2libGUgY291bnRlcnBhcnRzLlxyXG4gICAgICAgICAgICAvLyBGb3IgZ2FtZXMgdGhhdCBzaGFyZSB0aGUgc2FtZSBOYW1lIG9yIHRoZSBzYW1lIFN0ZWFtSWQsIGNvcHkgbm9uLXRyaXZpYWxcclxuICAgICAgICAgICAgLy8gQ29tcGxldGlvblN0YXR1cyBmcm9tIGhpZGRlbiBlbnRyaWVzIHRvIHRoZSBub24taGlkZGVuIGVudHJ5IGFuZFxyXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSBkaXN0aW5jdCBDYXRlZ29yaWVzLlxyXG4gICAgICAgICAgICBjb25zdCBtZWFuaW5nZnVsU3RhdHVzZXMgPSBuZXcgU2V0KFtudWxsLCAnTm90IFBsYXllZCcsICdQbGF5ZWQnXSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmlzaWJsZSBvZiB0aGlzLmFsbEdhbWVzLmZpbHRlcihnID0+ICFnLkhpZGRlbikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWQgPSB0aGlzLmFsbEdhbWVzLmZpbHRlcihwID0+IHAgIT09IHZpc2libGUgJiYgKHAuTmFtZSA9PT0gdmlzaWJsZS5OYW1lIHx8IChwLlN0ZWFtSWQgJiYgcC5TdGVhbUlkID09PSAodmlzaWJsZSBhcyBhbnkpLlN0ZWFtSWQpKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW5SZWxhdGVkID0gcmVsYXRlZC5maWx0ZXIocCA9PiBwLkhpZGRlbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGlkZGVuUmVsYXRlZC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvcHkgQ29tcGxldGlvblN0YXR1cyBmcm9tIHRoZSBmaXJzdCBoaWRkZW4gcmVsYXRlZCBlbnRyeSB0aGF0IGhhcyBhIG1lYW5pbmdmdWwgKG5vbi1kZWZhdWx0KSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoIG9mIGhpZGRlblJlbGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoY3MgPSBoLkNvbXBsZXRpb25TdGF0dXMgPz8gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGNzICE9IG51bGwgJiYgaGNzICE9PSAnTm90IFBsYXllZCcgJiYgaGNzICE9PSAnUGxheWVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZS5Db21wbGV0aW9uU3RhdHVzID09IG51bGwgfHwgdmlzaWJsZS5Db21wbGV0aW9uU3RhdHVzID09PSAnTm90IFBsYXllZCcgfHwgdmlzaWJsZS5Db21wbGV0aW9uU3RhdHVzID09PSAnUGxheWVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZS5Db21wbGV0aW9uU3RhdHVzID0gaGNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGlzdGluY3QgQ2F0ZWdvcmllcyBmcm9tIGhpZGRlbiByZWxhdGVkIGVudHJpZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhdHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlLkNhdGVnb3JpZXMpIHZpc2libGUuQ2F0ZWdvcmllcy5zcGxpdCgnfCcpLmZvckVhY2goYyA9PiB7IGlmIChjKSBjYXRzLmFkZChjKTsgfSk7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW5SZWxhdGVkLmZvckVhY2goaCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGguQ2F0ZWdvcmllcykgaC5DYXRlZ29yaWVzLnNwbGl0KCd8JykuZm9yRWFjaChjID0+IHsgaWYgKGMpIGNhdHMuYWRkKGMpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZS5DYXRlZ29yaWVzID0gY2F0cy5zaXplID4gMCA/IEFycmF5LmZyb20oY2F0cykuam9pbignfCcpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvdW50cyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGcgb2YgdGhpcy5hbGxHYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGcuQ29tcGxldGlvblN0YXR1cyA/PyAnPG51bGw+JztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb3VudHMuc2V0KGtleSwgKHN0YXR1c0NvdW50cy5nZXQoa2V5KSA/PyAwKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkID0gQXJyYXkuZnJvbShzdGF0dXNDb3VudHMuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0xpYnJhcnk6IENvbXBsZXRpb25TdGF0dXMgY291bnRzJywgc29ydGVkKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl9fY29tcGxldGlvblN0YXR1c0NvdW50cyA9IE9iamVjdC5mcm9tRW50cmllcyhzb3J0ZWQpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB3aGVuIHdpbmRvdyBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGhhcm1sZXNzIGRlYnVnIGZhaWx1cmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzQ2xpZW50U3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEZpbHRlck9wdGlvbnModGhpcy5hbGxHYW1lcyk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5nYW1lcyA9IHRoaXMuYWxsR2FtZXM7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xpYnJhcnkgbG9hZCBmYWlsZWQnLCBlcnIpO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEdhbWVzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEFsbEdhbWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFsbEdhbWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFByZWNvbXB1dGVkVmlld3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWRWaWV3cztcclxuICAgIH1cclxuXHJcbiAgICBzZXRQcmVjb21wdXRlZFZpZXcoa2V5OiBzdHJpbmcsIHZpZXc6IFByZWNvbXB1dGVkVmlldykge1xyXG4gICAgICAgIHRoaXMucHJlY29tcHV0ZWRWaWV3cy5zZXQoa2V5LCB2aWV3KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVmcmVzaEZpbHRlck9wdGlvbnMoZ2FtZXM6IEdhbWVbXSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlcyA9IEFycmF5LmZyb20obmV3IFNldChnYW1lcy5tYXAocCA9PiBwLlNvdXJjZSA/PyAnJykuZmlsdGVyKHMgPT4gcyAhPT0gJycpKSkuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuICAgICAgICB0aGlzLnRhZ3MgPSBBcnJheS5mcm9tKG5ldyBTZXQoZ2FtZXMuZmxhdE1hcChwID0+IChwLlRhZ3MgPz8gJycpLnNwbGl0KCd8JykpLmZpbHRlcihzID0+IHMpKSkuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuICAgICAgICB0aGlzLmdlbnJlcyA9IEFycmF5LmZyb20obmV3IFNldChnYW1lcy5mbGF0TWFwKHAgPT4gKHAuR2VucmVzID8/ICcnKS5zcGxpdCgnfCcpKS5maWx0ZXIocyA9PiBzKSkpLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XHJcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGdhbWVzLmZsYXRNYXAocCA9PiAocC5DYXRlZ29yaWVzID8/ICcnKS5zcGxpdCgnfCcpKS5maWx0ZXIocyA9PiBzKSkpLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XHJcbiAgICAgICAgY29uc3QgcnkgPSBBcnJheS5mcm9tKG5ldyBTZXQoZ2FtZXMubWFwKHAgPT4gcC5SZWxlYXNlWWVhcikuZmlsdGVyKCh5KTogeSBpcyBudW1iZXIgPT4geSAhPSBudWxsKSkpLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcclxuICAgICAgICB0aGlzLnJlbGVhc2VZZWFycyA9IHJ5Lm1hcChwID0+IHAudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgY29uc3QgYXkgPSBBcnJheS5mcm9tKG5ldyBTZXQoZ2FtZXMubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXAuQWRkZWQpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZCA9IHAuQWRkZWQgYXMgYW55O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhZGRlZCA9PT0gJ3N0cmluZycgJiYgYWRkZWQuaW5kZXhPZignL0RhdGUoJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUludChhZGRlZC5yZXBsYWNlKCcvRGF0ZSgnLCAnJykucmVwbGFjZSgnKS8nLCAnJykpKS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZHQgPSBuZXcgRGF0ZShhZGRlZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOYU4oZHQuZ2V0RnVsbFllYXIoKSkgPyBudWxsIDogZHQuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5maWx0ZXIoKHkpOiB5IGlzIG51bWJlciA9PiB5ICE9IG51bGwpKSkuc29ydCgoYSwgYikgPT4gYiAtIGEpO1xyXG4gICAgICAgIHRoaXMuYWRkZWRZZWFycyA9IGF5Lm1hcChwID0+IHAudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZlYXR1cmVzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgICAgICBnYW1lcy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgICAgICBwLkZlYXR1cmVzPy5zcGxpdCgnfCcpLmZvckVhY2goKGY6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgJiYgZi50cmltKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb3dlciA9IGYudHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlc01hcC5oYXMobG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzTWFwLnNldChsb3dlciwgZi50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IEFycmF5LmZyb20oZmVhdHVyZXNNYXAudmFsdWVzKCkpLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYiwgdW5kZWZpbmVkLCB7IHNlbnNpdGl2aXR5OiAnYmFzZScgfSkpO1xyXG5cclxuICAgICAgICB0aGlzLm11bHRpID0gQXJyYXkuZnJvbShuZXcgU2V0KGdhbWVzLmZsYXRNYXAocCA9PiAocC5NdWx0aSA/PyAnJykuc3BsaXQoJ3wnKSkuZmlsdGVyKHMgPT4gcykpKS5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xyXG4gICAgICAgIHRoaXMuYWdlUmF0aW5ncyA9IEFycmF5LmZyb20obmV3IFNldChnYW1lcy5tYXAocCA9PiBwLkFnZVJhdGluZyA/PyAnJykuZmlsdGVyKHMgPT4gcykpKS5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBsaWJyYXJ5ID0gbmV3IExpYnJhcnkoKTtcclxuZXhwb3J0IGRlZmF1bHQgbGlicmFyeTtcclxuIl0sIm5hbWVzIjpbIkdhbWUiLCJMaWJyYXJ5IiwibG9hZCIsInVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImluZGV4T2YiLCJyZXNwIiwiZmV0Y2giLCJNYXRoIiwicmFuZG9tIiwiZ3ppcEJsb2IiLCJibG9iIiwiZGVjb21wcmVzc2VkU3RyZWFtIiwic3RyZWFtIiwicGlwZVRocm91Z2giLCJEZWNvbXByZXNzaW9uU3RyZWFtIiwiZGVjb21wcmVzc2VkQmxvYiIsIlJlc3BvbnNlIiwiZGVjb21wcmVzc2VkVGV4dCIsInRleHQiLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJhbGxHYW1lcyIsIm1hcCIsImciLCJuZyIsImNvcHlQcm9wZXJ0eVZhbHVlc0Zyb20iLCJidW5kbGVDb3VudHMiLCJNYXAiLCJnYW1lIiwiQnVuZGxlcyIsImxlbmd0aCIsImJ1bmRsZSIsInNldCIsImdldCIsImJuZGxDbnQiLCJCdW5kbGUiLCJBZGRlZEJ1bmRsZSIsIkJvdWdodE1vbnRoIiwic3BsaXQiLCJkaWN0Q2F0ZWdvcnlIb3VycyIsIlBsYXl0aW1lIiwiQ2F0ZWdvcmllcyIsImNhdCIsInByZXYiLCJDYXRlZ29yeUhvdXJzIiwiZmlsdGVyIiwicCIsImhycyIsInJvdW5kIiwidG9TdHJpbmciLCJqb2luIiwiZ2FtZVRpbWVTdW1zIiwiZ2FtZU90aGVyU291cmNlcyIsIlNvdXJjZSIsIlN0ZWFtUGxheXRpbWUiLCJzYW1lTmFtZWRHYW1lcyIsIk5hbWUiLCJyZWR1Y2UiLCJhIiwiYiIsInNvcnQiLCJzb3VyY2VPcmRlciIsImFJbmRleCIsImJJbmRleCIsImxvY2FsZUNvbXBhcmUiLCJPdGhlclNvdXJjZXMiLCJ1cmkiLCJJZCIsImVuY29kZVVSSSIsIkdhbWVJZCIsIkRlY2siLCJCb3VnaHQiLCJDb21wbGV0aW9uU3RhdHVzIiwiY3MiLCJ0cmltIiwibWVhbmluZ2Z1bFN0YXR1c2VzIiwiU2V0IiwidmlzaWJsZSIsIkhpZGRlbiIsInJlbGF0ZWQiLCJTdGVhbUlkIiwiaGlkZGVuUmVsYXRlZCIsImgiLCJoY3MiLCJjYXRzIiwiZm9yRWFjaCIsImMiLCJhZGQiLCJzaXplIiwiQXJyYXkiLCJmcm9tIiwic3RhdHVzQ291bnRzIiwia2V5Iiwic29ydGVkIiwiZW50cmllcyIsImNvbnNvbGUiLCJpbmZvIiwiX19jb21wbGV0aW9uU3RhdHVzQ291bnRzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlIiwiaXNDbGllbnRTdGFydGVkIiwiX3ByZWxvYWRlZCIsInJlZnJlc2hGaWx0ZXJPcHRpb25zIiwiZ2FtZXMiLCJlcnIiLCJlcnJvciIsImdldEFsbEdhbWVzIiwiZ2V0UHJlY29tcHV0ZWRWaWV3cyIsInByZWNvbXB1dGVkVmlld3MiLCJzZXRQcmVjb21wdXRlZFZpZXciLCJ2aWV3Iiwic291cmNlcyIsInMiLCJ0YWdzIiwiZmxhdE1hcCIsIlRhZ3MiLCJnZW5yZXMiLCJHZW5yZXMiLCJjYXRlZ29yaWVzIiwicnkiLCJSZWxlYXNlWWVhciIsInkiLCJyZWxlYXNlWWVhcnMiLCJheSIsIkFkZGVkIiwiYWRkZWQiLCJEYXRlIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiZ2V0RnVsbFllYXIiLCJkdCIsImlzTmFOIiwiYWRkZWRZZWFycyIsImZlYXR1cmVzTWFwIiwiRmVhdHVyZXMiLCJmIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImhhcyIsImZlYXR1cmVzIiwidmFsdWVzIiwidW5kZWZpbmVkIiwic2Vuc2l0aXZpdHkiLCJtdWx0aSIsIk11bHRpIiwiYWdlUmF0aW5ncyIsIkFnZVJhdGluZyIsImNvbnN0cnVjdG9yIiwicmVhZHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxpYnJhcnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/Library.ts\n"));

/***/ })

});